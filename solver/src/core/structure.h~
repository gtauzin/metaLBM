#ifndef STRUCTURE_H
#define STRUCTURE_H

#include <iostream>
#include <algorithm>
#include <functional>
#include <cmath>

namespace lbm {

  template<int Begin, int End, int Step, int LoopNumber = 1>
    struct UnrolledFor {
      template<typename F>
      static void Do (F f) {
        std::bind(f, _LoopNumber = Begin)
        f(Begin);
        UnrolledFor<Begin+Step, End, Step, LoopNumber>::Do(f);
      }
    };

  template<int End>
    struct UnrolledFor<End, End> {
    template<typename F>
      static void Do (F f) {
    }
  };

  template <int CurrentLoopNumber, int MaximumLoopNumber, int* Begin, int* End, int* Step>
    struct Nest {
      template <typename F>
      void Call(F f) {
        UnrolledFor<Begin[CurrentLoopNumber], End[CurrentLoopNumber], Step[CurrentLoopNumber]>::Do(Call(f))
          }
    };

  template <MaximumLoopNumber, int* Begin, int* End, int* Step>
    struct Nest<MaximumLoopNumber, MaximumLoopNumber, Begin, End, Step> {
    template <typename F>
      void Call(F f) {
      f();
    }
  };


  template<class T, unsigned int size>
    class MathVector
  {

    T mV[size];

  public:
    T sum(){
      T sumR = 0;
      UnrolledFor<0, size>::Do([&] (int i) {
          sumR += mV[i];
        })

        return sumR;
    }

    T norm2(){
      T norm2R = 0;
      UnrolledFor<0, size>::Do([&] (int i) {
          norm2R += mV[i] * mV[i];
        })

        return norm2R;
    }

    T dot(MathVector<T, size> other){
      T dotR = 0;

      UnrolledFor<0, size>::Do([&] (int i) {
          dotR += mV[i]*other[i];
        })

        return dotR;
    }

    T magnitude(){
      return sqrt(this->norm2());
    }

    MathVector<T, size>& operator=(const MathVector<T, size>& other){
      UnrolledFor<0, size>::Do([&] (int i) {
          mV[i] = other[i];
        })

      return *this;
    }

    MathVector<T, size>& operator=(const T other[size]){
      UnrolledFor<0, size>::Do([&] (int i) {
          mV[i] = other[i];
        })

      return *this;
    }

    T& operator[] (int i) {
      return mV[i];
    }

    const T& operator[] (int i) const {
      return mV[i];
    }

  };


  template<class T, unsigned int size>
    std::ostream& operator<<(std::ostream& os, const MathVector<T, size>& mV){
    os << "[ ";
    UnrolledFor<0, size>::Do([&] (int i) {
        os << mV[i] << " ";
      })
      os << "]\n";
    return os;
  }

  template<class T, unsigned int size>
    MathVector<T, size>& operator+=(MathVector<T, size>& mV_a, const MathVector<T, size>& mV_b)
    {
      UnrolledFor<0, size>::Do([&] (int i) {
          mV_a[i] += mV_b[i];
        })

        return mV_a;
    }

  template<class T, unsigned int size>
    MathVector<T, size> operator+(const MathVector<T, size>& mV_a, const MathVector<T, size>& mV_b)
    {
      MathVector<T, size> mV_c;
      UnrolledFor<0, size>::Do([&] (int i) {
          mV_c[i] = mV_a[i] + mV_b[i];
        })
        return mV_c;
    }

  template<class T, unsigned int size>
    MathVector<T, size>& operator*=(MathVector<T, size>& mV, const T factor)
    {
      UnrolledFor<0, size>::Do([&] (int i) {
          mV[i] *= factor;
        })

        return mV;
    }

  template<class T, unsigned int size>
    MathVector<T, size> operator*(const MathVector<T, size>& mV_in, const T factor)
    {
      MathVector<T, size> mV;
      UnrolledFor<0, size>::Do([&] (int i) {
          mV[i] = mV_in[i] * factor;
        })

        return mV;
    }

  template<class T, unsigned int size>
    MathVector<T, size> operator*(const T factor, const MathVector<T, size>& mV_in)
    {
      MathVector<T, size> mV;
      UnrolledFor<0, size>::Do([&] (int i) {
          mV[i] = factor * mV_in[i];
        })

        return mV;
    }


    template<class T, unsigned int size>
    MathVector<T, size>& operator/=(MathVector<T, size>& mV, const T factor)
    {
      UnrolledFor<0, size>::Do([&] (int i) {
          mV[i] /= factor;
        })

        return mV;
    }

  template<class T, unsigned int size>
    MathVector<T, size> operator/(const MathVector<T, size>& mV_in, const T factor)
    {
      MathVector<T, size> mV;
      UnrolledFor<0, size>::Do([&] (int i) {
          mV[i] = mV_in[i] / factor;
        })

        return mV;
    }

  template<class T, unsigned int size>
    MathVector<T, size>& operator-=(MathVector<T, size>& mV_a, const MathVector<T, size>& mV_b)
    {
      UnrolledFor<0, size>::Do([&] (int i) {
          mV_a[i] -= mV_b[i];
        })

        return mV_a;
    }

  template<class T, unsigned int size>
    MathVector<T, size> operator-(const MathVector<T, size>& mV_a, const MathVector<T, size>& mV_b)
    {
      MathVector<T, size> mV_c;
      UnrolledFor<0, size>::Do([&] (int i) {
          mV_c[i] = mV_a[i] - mV_b[i];
        })

        return mV_c;
    }


}
#endif // STRUCTURE_H
